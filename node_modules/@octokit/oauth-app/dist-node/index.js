'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var OAuthAppAuth = require('@octokit/auth-oauth-app');
var core = require('@octokit/core');
var universalUserAgent = require('universal-user-agent');
var authOauthUser = require('@octokit/auth-oauth-user');
var OAuthMethods = require('@octokit/oauth-methods');
var authUnauthenticated = require('@octokit/auth-unauthenticated');
var fromEntries = _interopDefault(require('fromentries'));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const VERSION = "3.3.2";

function addEventHandler(state, eventName, eventHandler) {
  if (Array.isArray(eventName)) {
    for (const singleEventName of eventName) {
      addEventHandler(state, singleEventName, eventHandler);
    }

    return;
  }

  if (!state.eventHandlers[eventName]) {
    state.eventHandlers[eventName] = [];
  }

  state.eventHandlers[eventName].push(eventHandler);
}

const OAuthAppOctokit = core.Octokit.defaults({
  userAgent: `octokit-oauth-app.js/${VERSION} ${universalUserAgent.getUserAgent()}`
});

async function getUserOctokitWithState(state, options) {
  return state.octokit.auth(_objectSpread2(_objectSpread2({
    type: "oauth-user"
  }, options), {}, {
    factory(options) {
      return new state.Octokit({
        authStrategy: authOauthUser.createOAuthUserAuth,
        auth: options
      });
    }

  }));
}

function getWebFlowAuthorizationUrlWithState(state, options) {
  const optionsWithDefaults = _objectSpread2(_objectSpread2({
    clientId: state.clientId,
    request: state.octokit.request
  }, options), {}, {
    allowSignup: options.allowSignup || state.allowSignup,
    scopes: options.scopes || state.defaultScopes
  });

  return OAuthMethods.getWebFlowAuthorizationUrl(_objectSpread2({
    clientType: state.clientType
  }, optionsWithDefaults));
}

async function emitEvent(state, context) {
  const {
    name,
    action
  } = context;

  if (state.eventHandlers[`${name}.${action}`]) {
    for (const eventHandler of state.eventHandlers[`${name}.${action}`]) {
      await eventHandler(context);
    }
  }

  if (state.eventHandlers[name]) {
    for (const eventHandler of state.eventHandlers[name]) {
      await eventHandler(context);
    }
  }
}

async function createTokenWithState(state, options) {
  const authentication = await state.octokit.auth(_objectSpread2({
    type: "oauth-user"
  }, options));
  await emitEvent(state, {
    name: "token",
    action: "created",
    token: authentication.token,
    scopes: authentication.scopes,
    authentication,
    octokit: new state.Octokit({
      authStrategy: OAuthAppAuth.createOAuthUserAuth,
      auth: {
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        token: authentication.token,
        scopes: authentication.scopes,
        refreshToken: authentication.refreshToken,
        expiresAt: authentication.expiresAt,
        refreshTokenExpiresAt: authentication.refreshTokenExpiresAt
      }
    })
  });
  return {
    authentication
  };
}

async function checkTokenWithState(state, options) {
  return await OAuthMethods.checkToken(_objectSpread2({
    // @ts-expect-error not worth the extra code to appease TS
    clientType: state.clientType,
    clientId: state.clientId,
    clientSecret: state.clientSecret,
    request: state.octokit.request
  }, options));
}

async function resetTokenWithState(state, options) {
  const optionsWithDefaults = _objectSpread2({
    clientId: state.clientId,
    clientSecret: state.clientSecret,
    request: state.octokit.request
  }, options);

  if (state.clientType === "oauth-app") {
    const response = await OAuthMethods.resetToken(_objectSpread2({
      clientType: "oauth-app"
    }, optionsWithDefaults));
    await emitEvent(state, {
      name: "token",
      action: "reset",
      token: response.authentication.token,
      scopes: response.authentication.scopes || undefined,
      authentication: _objectSpread2({
        type: "token",
        tokenType: "oauth"
      }, response.authentication),
      octokit: new state.Octokit({
        authStrategy: authOauthUser.createOAuthUserAuth,
        auth: {
          clientType: state.clientType,
          clientId: state.clientId,
          clientSecret: state.clientSecret,
          token: response.authentication.token,
          scopes: response.authentication.scopes
        }
      })
    });
    return response;
  }

  const response = await OAuthMethods.resetToken(_objectSpread2({
    clientType: "github-app"
  }, optionsWithDefaults));
  await emitEvent(state, {
    name: "token",
    action: "reset",
    token: response.authentication.token,
    authentication: _objectSpread2({
      type: "token",
      tokenType: "oauth"
    }, response.authentication),
    octokit: new state.Octokit({
      authStrategy: authOauthUser.createOAuthUserAuth,
      auth: {
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        token: response.authentication.token
      }
    })
  });
  return response;
}

async function refreshTokenWithState(state, options) {
  if (state.clientType === "oauth-app") {
    throw new Error("[@octokit/oauth-app] app.refreshToken() is not supported for OAuth Apps");
  }

  const response = await OAuthMethods.refreshToken({
    clientType: "github-app",
    clientId: state.clientId,
    clientSecret: state.clientSecret,
    request: state.octokit.request,
    refreshToken: options.refreshToken
  });
  await emitEvent(state, {
    name: "token",
    action: "refreshed",
    token: response.authentication.token,
    authentication: _objectSpread2({
      type: "token",
      tokenType: "oauth"
    }, response.authentication),
    octokit: new state.Octokit({
      authStrategy: authOauthUser.createOAuthUserAuth,
      auth: {
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        token: response.authentication.token
      }
    })
  });
  return response;
}

async function scopeTokenWithState(state, options) {
  if (state.clientType === "oauth-app") {
    throw new Error("[@octokit/oauth-app] app.scopeToken() is not supported for OAuth Apps");
  }

  const response = await OAuthMethods.scopeToken(_objectSpread2({
    clientType: "github-app",
    clientId: state.clientId,
    clientSecret: state.clientSecret,
    request: state.octokit.request
  }, options));
  await emitEvent(state, {
    name: "token",
    action: "scoped",
    token: response.authentication.token,
    authentication: _objectSpread2({
      type: "token",
      tokenType: "oauth"
    }, response.authentication),
    octokit: new state.Octokit({
      authStrategy: authOauthUser.createOAuthUserAuth,
      auth: {
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        token: response.authentication.token
      }
    })
  });
  return response;
}

async function deleteTokenWithState(state, options) {
  const optionsWithDefaults = _objectSpread2({
    clientId: state.clientId,
    clientSecret: state.clientSecret,
    request: state.octokit.request
  }, options);

  const response = state.clientType === "oauth-app" ? await OAuthMethods.deleteToken(_objectSpread2({
    clientType: "oauth-app"
  }, optionsWithDefaults)) : // istanbul ignore next
  await OAuthMethods.deleteToken(_objectSpread2({
    clientType: "github-app"
  }, optionsWithDefaults));
  await emitEvent(state, {
    name: "token",
    action: "deleted",
    token: options.token,
    octokit: new state.Octokit({
      authStrategy: authUnauthenticated.createUnauthenticatedAuth,
      auth: {
        reason: `Handling "token.deleted" event. The access for the token has been revoked.`
      }
    })
  });
  return response;
}

async function deleteAuthorizationWithState(state, options) {
  const optionsWithDefaults = _objectSpread2({
    clientId: state.clientId,
    clientSecret: state.clientSecret,
    request: state.octokit.request
  }, options);

  const response = state.clientType === "oauth-app" ? await OAuthMethods.deleteAuthorization(_objectSpread2({
    clientType: "oauth-app"
  }, optionsWithDefaults)) : // istanbul ignore next
  await OAuthMethods.deleteAuthorization(_objectSpread2({
    clientType: "github-app"
  }, optionsWithDefaults));
  await emitEvent(state, {
    name: "token",
    action: "deleted",
    token: options.token,
    octokit: new state.Octokit({
      authStrategy: authUnauthenticated.createUnauthenticatedAuth,
      auth: {
        reason: `Handling "token.deleted" event. The access for the token has been revoked.`
      }
    })
  });
  await emitEvent(state, {
    name: "authorization",
    action: "deleted",
    token: options.token,
    octokit: new state.Octokit({
      authStrategy: authUnauthenticated.createUnauthenticatedAuth,
      auth: {
        reason: `Handling "authorization.deleted" event. The access for the app has been revoked.`
      }
    })
  });
  return response;
}

// @ts-ignore remove once Node 10 is out maintenance. Replace with Object.fromEntries
async function parseRequest(request) {
  const {
    searchParams
  } = new URL(request.url, "http://localhost");
  const query = fromEntries(searchParams);
  const headers = request.headers;

  if (!["POST", "PATCH"].includes(request.method)) {
    return {
      headers,
      query
    };
  }

  return new Promise((resolve, reject) => {
    let bodyChunks = [];
    request.on("error", reject).on("data", chunk => bodyChunks.push(chunk)).on("end", async () => {
      const bodyString = Buffer.concat(bodyChunks).toString();
      if (!bodyString) return resolve({
        headers,
        query
      });

      try {
        resolve({
          headers,
          query,
          body: JSON.parse(bodyString)
        });
      } catch (error) {
        reject(error);
      }
    });
  });
}

async function middleware(app, options, request, response) {
  // request.url mayb include ?query parameters which we don't want for `route`
  // hence the workaround using new URL()
  const {
    pathname
  } = new URL(request.url, "http://localhost");
  const route = [request.method, pathname].join(" ");
  const routes = {
    getLogin: `GET ${options.pathPrefix}/login`,
    getCallback: `GET ${options.pathPrefix}/callback`,
    createToken: `POST ${options.pathPrefix}/token`,
    getToken: `GET ${options.pathPrefix}/token`,
    patchToken: `PATCH ${options.pathPrefix}/token`,
    patchRefreshToken: `PATCH ${options.pathPrefix}/refresh-token`,
    scopeToken: `POST ${options.pathPrefix}/token/scoped`,
    deleteToken: `DELETE ${options.pathPrefix}/token`,
    deleteGrant: `DELETE ${options.pathPrefix}/grant`
  };

  if (!Object.values(routes).includes(route)) {
    options.onUnhandledRequest(request, response);
    return;
  }

  let parsedRequest;

  try {
    parsedRequest = await parseRequest(request);
  } catch (error) {
    response.writeHead(400, {
      "content-type": "application/json"
    });
    return response.end(JSON.stringify({
      error: "[@octokit/oauth-app] request error"
    }));
  }

  const {
    headers,
    query,
    body = {}
  } = parsedRequest;

  try {
    var _headers$authorizatio6;

    if (route === routes.getLogin) {
      var _query$scopes;

      const {
        url
      } = app.getWebFlowAuthorizationUrl({
        state: query.state,
        scopes: (_query$scopes = query.scopes) === null || _query$scopes === void 0 ? void 0 : _query$scopes.split(","),
        allowSignup: query.allowSignup,
        redirectUrl: query.redirectUrl
      });
      response.writeHead(302, {
        location: url
      });
      return response.end();
    }

    if (route === routes.getCallback) {
      if (query.error) {
        throw new Error(`[@octokit/oauth-app] ${query.error} ${query.error_description}`);
      }

      if (!query.state || !query.code) {
        throw new Error('[@octokit/oauth-app] Both "code" & "state" parameters are required');
      }

      const {
        authentication: {
          token
        }
      } = await app.createToken({
        state: query.state,
        code: query.code
      });
      response.writeHead(200, {
        "content-type": "text/html"
      });
      response.write(`<h1>Token created successfull</h1>
    
<p>Your token is: <strong>${token}</strong>. Copy it now as it cannot be shown again.</p>`);
      return response.end();
    }

    if (route === routes.createToken) {
      const {
        state: oauthState,
        code,
        redirectUrl
      } = body;

      if (!oauthState || !code) {
        throw new Error('[@octokit/oauth-app] Both "code" & "state" parameters are required');
      }

      const {
        authentication: {
          token,
          scopes
        }
      } = await app.createToken({
        state: oauthState,
        code,
        redirectUrl
      });
      response.writeHead(201, {
        "content-type": "application/json"
      });
      return response.end(JSON.stringify({
        token,
        scopes
      }));
    }

    if (route === routes.getToken) {
      var _headers$authorizatio;

      const token = (_headers$authorizatio = headers.authorization) === null || _headers$authorizatio === void 0 ? void 0 : _headers$authorizatio.substr("token ".length);

      if (!token) {
        throw new Error('[@octokit/oauth-app] "Authorization" header is required');
      }

      const result = await app.checkToken({
        token
      });
      response.writeHead(200, {
        "content-type": "application/json"
      });
      return response.end(JSON.stringify(result));
    }

    if (route === routes.patchToken) {
      var _headers$authorizatio2;

      const token = (_headers$authorizatio2 = headers.authorization) === null || _headers$authorizatio2 === void 0 ? void 0 : _headers$authorizatio2.substr("token ".length);

      if (!token) {
        throw new Error('[@octokit/oauth-app] "Authorization" header is required');
      }

      const result = await app.resetToken({
        token
      });
      response.writeHead(200, {
        "content-type": "application/json"
      });
      return response.end(JSON.stringify(result));
    }

    if (route === routes.patchRefreshToken) {
      var _headers$authorizatio3;

      const token = (_headers$authorizatio3 = headers.authorization) === null || _headers$authorizatio3 === void 0 ? void 0 : _headers$authorizatio3.substr("token ".length);

      if (!token) {
        throw new Error('[@octokit/oauth-app] "Authorization" header is required');
      }

      const {
        refreshToken
      } = body;

      if (!refreshToken) {
        throw new Error("[@octokit/oauth-app] refreshToken must be sent in request body");
      }

      const result = await app.refreshToken({
        refreshToken
      });
      response.writeHead(200, {
        "content-type": "application/json"
      });
      return response.end(JSON.stringify(result));
    }

    if (route === routes.scopeToken) {
      var _headers$authorizatio4;

      const token = (_headers$authorizatio4 = headers.authorization) === null || _headers$authorizatio4 === void 0 ? void 0 : _headers$authorizatio4.substr("token ".length);

      if (!token) {
        throw new Error('[@octokit/oauth-app] "Authorization" header is required');
      }

      const result = await app.scopeToken(_objectSpread2({
        token
      }, body));
      response.writeHead(200, {
        "content-type": "application/json"
      });
      return response.end(JSON.stringify(result));
    }

    if (route === routes.deleteToken) {
      var _headers$authorizatio5;

      const token = (_headers$authorizatio5 = headers.authorization) === null || _headers$authorizatio5 === void 0 ? void 0 : _headers$authorizatio5.substr("token ".length);

      if (!token) {
        throw new Error('[@octokit/oauth-app] "Authorization" header is required');
      }

      await app.deleteToken({
        token
      });
      response.writeHead(204);
      return response.end();
    } // route === routes.deleteGrant


    const token = (_headers$authorizatio6 = headers.authorization) === null || _headers$authorizatio6 === void 0 ? void 0 : _headers$authorizatio6.substr("token ".length);

    if (!token) {
      throw new Error('[@octokit/oauth-app] "Authorization" header is required');
    }

    await app.deleteAuthorization({
      token
    });
    response.writeHead(204);
    return response.end();
  } catch (error) {
    response.writeHead(400, {
      "content-type": "application/json"
    });
    response.end(JSON.stringify({
      error: error.message
    }));
  }
}

function onUnhandledRequestDefault(request, response) {
  response.writeHead(404, {
    "content-type": "application/json"
  });
  response.end(JSON.stringify({
    error: `Unknown route: ${request.method} ${request.url}`
  }));
}

function createNodeMiddleware(app, {
  pathPrefix = "/api/github/oauth",
  onUnhandledRequest = onUnhandledRequestDefault
} = {}) {
  return middleware.bind(null, app, {
    pathPrefix,
    onUnhandledRequest
  });
}

class OAuthApp {
  constructor(options) {
    const Octokit = options.Octokit || OAuthAppOctokit;
    this.type = options.clientType || "oauth-app";
    const octokit = new Octokit({
      authStrategy: OAuthAppAuth.createOAuthAppAuth,
      auth: {
        clientType: this.type,
        clientId: options.clientId,
        clientSecret: options.clientSecret
      }
    });
    const state = {
      clientType: this.type,
      clientId: options.clientId,
      clientSecret: options.clientSecret,
      // @ts-expect-error defaultScopes not permitted for GitHub Apps
      defaultScopes: options.defaultScopes || [],
      allowSignup: options.allowSignup,
      baseUrl: options.baseUrl,
      log: options.log,
      Octokit,
      octokit,
      eventHandlers: {}
    };
    this.on = addEventHandler.bind(null, state); // @ts-expect-error TODO: figure this out

    this.octokit = octokit;
    this.getUserOctokit = getUserOctokitWithState.bind(null, state);
    this.getWebFlowAuthorizationUrl = getWebFlowAuthorizationUrlWithState.bind(null, state);
    this.createToken = createTokenWithState.bind(null, state);
    this.checkToken = checkTokenWithState.bind(null, state);
    this.resetToken = resetTokenWithState.bind(null, state);
    this.refreshToken = refreshTokenWithState.bind(null, state);
    this.scopeToken = scopeTokenWithState.bind(null, state);
    this.deleteToken = deleteTokenWithState.bind(null, state);
    this.deleteAuthorization = deleteAuthorizationWithState.bind(null, state);
  }

  static defaults(defaults) {
    const OAuthAppWithDefaults = class extends this {
      constructor(...args) {
        super(_objectSpread2(_objectSpread2({}, defaults), args[0]));
      }

    };
    return OAuthAppWithDefaults;
  }

}
OAuthApp.VERSION = VERSION;

exports.OAuthApp = OAuthApp;
exports.createNodeMiddleware = createNodeMiddleware;
//# sourceMappingURL=index.js.map
